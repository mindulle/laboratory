Package rand
============

-   `import "math/rand"`
-   [Overview](#pkg-overview)
-   [Index](#pkg-index)
-   [Examples](#pkg-examples)

Overview 
--------

Package rand implements pseudo-random number generators suitable for
tasks such as simulation, but it should not be used for
security-sensitive work.

Random numbers are generated by a [Source](#Source), usually wrapped in
a [Rand](#Rand). Both types should be used by a single goroutine at a
time: sharing among multiple goroutines requires some kind of
synchronization.

Top-level functions, such as [Float64](#Float64) and [Int](#Int), are
safe for concurrent use by multiple goroutines.

This package\'s outputs might be easily predictable regardless of how
it\'s seeded. For random numbers suitable for security-sensitive work,
see the crypto/rand package.

#### [Example]

Code:

```go
answers := []string{
    "It is certain",
    "It is decidedly so",
    "Without a doubt",
    "Yes definitely",
    "You may rely on it",
    "As I see it yes",
    "Most likely",
    "Outlook good",
    "Yes",
    "Signs point to yes",
    "Reply hazy try again",
    "Ask again later",
    "Better not tell you now",
    "Cannot predict now",
    "Concentrate and ask again",
    "Don't count on it",
    "My reply is no",
    "My sources say no",
    "Outlook not so good",
    "Very doubtful",
}
fmt.Println("Magic 8-Ball says:", answers[rand.Intn(len(answers))])
```

#### [Example (Rand)]

This example shows the use of each of the methods on a \*Rand. The use
of the global functions is the same, without the receiver.

Code:

```go
// Create and seed the generator.
// Typically a non-fixed seed should be used, such as time.Now().UnixNano().
// Using a fixed seed will produce the same output on every run.
r := rand.New(rand.NewSource(99))

// The tabwriter here helps us generate aligned output.
w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
defer w.Flush()
show := func(name string, v1, v2, v3 any) {
    fmt.Fprintf(w, "%s\t%v\t%v\t%v\n", name, v1, v2, v3)
}

// Float32 and Float64 values are in [0, 1).
show("Float32", r.Float32(), r.Float32(), r.Float32())
show("Float64", r.Float64(), r.Float64(), r.Float64())

// ExpFloat64 values have an average of 1 but decay exponentially.
show("ExpFloat64", r.ExpFloat64(), r.ExpFloat64(), r.ExpFloat64())

// NormFloat64 values have an average of 0 and a standard deviation of 1.
show("NormFloat64", r.NormFloat64(), r.NormFloat64(), r.NormFloat64())

// Int31, Int63, and Uint32 generate values of the given width.
// The Int method (not shown) is like either Int31 or Int63
// depending on the size of 'int'.
show("Int31", r.Int31(), r.Int31(), r.Int31())
show("Int63", r.Int63(), r.Int63(), r.Int63())
show("Uint32", r.Uint32(), r.Uint32(), r.Uint32())

// Intn, Int31n, and Int63n limit their output to be < n.
// They do so more carefully than using r.Int()%n.
show("Intn(10)", r.Intn(10), r.Intn(10), r.Intn(10))
show("Int31n(10)", r.Int31n(10), r.Int31n(10), r.Int31n(10))
show("Int63n(10)", r.Int63n(10), r.Int63n(10), r.Int63n(10))

// Perm generates a random permutation of the numbers [0, n).
show("Perm", r.Perm(5), r.Perm(5), r.Perm(5))
```

Output:

```go
Float32     0.2635776           0.6358173           0.6718283
Float64     0.628605430454327   0.4504798828572669  0.9562755949377957
ExpFloat64  0.3362240648200941  1.4256072328483647  0.24354758816173044
NormFloat64 0.17233959114940064 1.577014951434847   0.04259129641113857
Int31       1501292890          1486668269          182840835
Int63       3546343826724305832 5724354148158589552 5239846799706671610
Uint32      2760229429          296659907           1922395059
Intn(10)    1                   2                   5
Int31n(10)  4                   7                   8
Int63n(10)  7                   6                   3
Perm        [1 4 2 3 0]         [4 2 1 3 0]         [1 2 4 0 3]
```

Index 
-----

-   [func ExpFloat64() float64](#ExpFloat64)
-   [func Float32() float32](#Float32)
-   [func Float64() float64](#Float64)
-   [func Int() int](#Int)
-   [func Int31() int32](#Int31)
-   [func Int31n(n int32) int32](#Int31n)
-   [func Int63() int64](#Int63)
-   [func Int63n(n int64) int64](#Int63n)
-   [func Intn(n int) int](#Intn)
-   [func NormFloat64() float64](#NormFloat64)
-   [func Perm(n int) \[\]int](#Perm)
-   [func Read(p \[\]byte) (n int, err error)](#Read)
-   [func Seed(seed int64)](#Seed)
-   [func Shuffle(n int, swap func(i, j int))](#Shuffle)
-   [func Uint32() uint32](#Uint32)
-   [func Uint64() uint64](#Uint64)
-   [type Rand](#Rand)
-   [func New(src Source) \*Rand](#New)
-   [func (r \*Rand) ExpFloat64() float64](#Rand.ExpFloat64)
-   [func (r \*Rand) Float32() float32](#Rand.Float32)
-   [func (r \*Rand) Float64() float64](#Rand.Float64)
-   [func (r \*Rand) Int() int](#Rand.Int)
-   [func (r \*Rand) Int31() int32](#Rand.Int31)
-   [func (r \*Rand) Int31n(n int32) int32](#Rand.Int31n)
-   [func (r \*Rand) Int63() int64](#Rand.Int63)
-   [func (r \*Rand) Int63n(n int64) int64](#Rand.Int63n)
-   [func (r \*Rand) Intn(n int) int](#Rand.Intn)
-   [func (r \*Rand) NormFloat64() float64](#Rand.NormFloat64)
-   [func (r \*Rand) Perm(n int) \[\]int](#Rand.Perm)
-   [func (r \*Rand) Read(p \[\]byte) (n int, err error)](#Rand.Read)
-   [func (r \*Rand) Seed(seed int64)](#Rand.Seed)
-   [func (r \*Rand) Shuffle(n int, swap func(i, j int))](#Rand.Shuffle)
-   [func (r \*Rand) Uint32() uint32](#Rand.Uint32)
-   [func (r \*Rand) Uint64() uint64](#Rand.Uint64)
-   [type Source](#Source)
-   [func NewSource(seed int64) Source](#NewSource)
-   [type Source64](#Source64)
-   [type Zipf](#Zipf)
-   [func NewZipf(r \*Rand, s float64, v float64, imax uint64)
    \*Zipf](#NewZipf)
-   [func (z \*Zipf) Uint64() uint64](#Zipf.Uint64)

 
### Examples

[Package](#example_)

[Intn](#example_Intn)

[Perm](#example_Perm)

[Shuffle](#example_Shuffle)

[Shuffle
(SlicesInUnison)](#example_Shuffle_slicesInUnison)

[Package (Rand)](#example__rand)


### Package files

exp.go normal.go rand.go rng.go zipf.go

func ExpFloat64 
---------------

```go
func ExpFloat64() float64
```

ExpFloat64 returns an exponentially distributed float64 in the range (0,
+math.MaxFloat64\] with an exponential distribution whose rate parameter
(lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To
produce a distribution with a different rate parameter, callers can
adjust the output using:

```go
sample = ExpFloat64() / desiredRateParameter
```

func Float32 
------------

```go
func Float32() float32
```

Float32 returns, as a float32, a pseudo-random number in the half-open
interval \[0.0,1.0) from the default Source.

func Float64 
------------

```go
func Float64() float64
```

Float64 returns, as a float64, a pseudo-random number in the half-open
interval \[0.0,1.0) from the default Source.

func Int 
--------

```go
func Int() int
```

Int returns a non-negative pseudo-random int from the default Source.

func Int31 
----------

```go
func Int31() int32
```

Int31 returns a non-negative pseudo-random 31-bit integer as an int32
from the default Source.

func Int31n 
-----------

```go
func Int31n(n int32) int32
```

Int31n returns, as an int32, a non-negative pseudo-random number in the
half-open interval \[0,n) from the default Source. It panics if n \<= 0.

func Int63 
----------

```go
func Int63() int64
```

Int63 returns a non-negative pseudo-random 63-bit integer as an int64
from the default Source.

func Int63n 
-----------

```go
func Int63n(n int64) int64
```

Int63n returns, as an int64, a non-negative pseudo-random number in the
half-open interval \[0,n) from the default Source. It panics if n \<= 0.

func Intn 
---------

```go
func Intn(n int) int
```

Intn returns, as an int, a non-negative pseudo-random number in the
half-open interval \[0,n) from the default Source. It panics if n \<= 0.

#### [Example]

Code:

```go
fmt.Println(rand.Intn(100))
fmt.Println(rand.Intn(100))
fmt.Println(rand.Intn(100))
```

func NormFloat64 
----------------

```go
func NormFloat64() float64
```

NormFloat64 returns a normally distributed float64 in the range
\[-math.MaxFloat64, +math.MaxFloat64\] with standard normal distribution
(mean = 0, stddev = 1) from the default Source. To produce a different
normal distribution, callers can adjust the output using:

```go
sample = NormFloat64() * desiredStdDev + desiredMean
```

func Perm 
---------

```go
func Perm(n int) []int
```

Perm returns, as a slice of n ints, a pseudo-random permutation of the
integers in the half-open interval \[0,n) from the default Source.

#### [Example]

Code:

```go
for _, value := range rand.Perm(3) {
    fmt.Println(value)
}
```

Output:

```go
1
2
0
```

func Read 
----------------------------------------

```go
func Read(p []byte) (n int, err error)
```

Read generates len(p) random bytes from the default Source and writes
them into p. It always returns len(p) and a nil error. Read, unlike the
Rand.Read method, is safe for concurrent use.

Deprecated: For almost all use cases, crypto/rand.Read is more
appropriate.

func Seed 
---------

```go
func Seed(seed int64)
```

Seed uses the provided seed value to initialize the default Source to a
deterministic state. Seed values that have the same remainder when
divided by 2³¹-1 generate the same pseudo-random sequence. Seed, unlike
the Rand.Seed method, is safe for concurrent use.

If Seed is not called, the generator is seeded randomly at program
startup.

Prior to Go 1.20, the generator was seeded like Seed(1) at program
startup. To force the old behavior, call Seed(1) at program startup.
Alternately, set GODEBUG=randautoseed=0 in the environment before making
any calls to functions in this package.

Deprecated: As of Go 1.20 there is no reason to call Seed with a random
value. Programs that call Seed with a known value to get a specific
sequence of results should use New(NewSource(seed)) to obtain a local
random generator.

func Shuffle 
---------------------------------------------

```go
func Shuffle(n int, swap func(i, j int))
```

Shuffle pseudo-randomizes the order of elements using the default
Source. n is the number of elements. Shuffle panics if n \< 0. swap
swaps the elements with indexes i and j.

#### [Example]

Code:

```go
words := strings.Fields("ink runs from the corners of my mouth")
rand.Shuffle(len(words), func(i, j int) {
    words[i], words[j] = words[j], words[i]
})
fmt.Println(words)
```

#### [Example (SlicesInUnison)]

Code:

```go
numbers := []byte("12345")
letters := []byte("ABCDE")
// Shuffle numbers, swapping corresponding entries in letters at the same time.
rand.Shuffle(len(numbers), func(i, j int) {
    numbers[i], numbers[j] = numbers[j], numbers[i]
    letters[i], letters[j] = letters[j], letters[i]
})
for i := range numbers {
    fmt.Printf("%c: %c\n", letters[i], numbers[i])
}
```

func Uint32 
-----------

```go
func Uint32() uint32
```

Uint32 returns a pseudo-random 32-bit value as a uint32 from the default
Source.

func Uint64 
------------------------------------------

```go
func Uint64() uint64
```

Uint64 returns a pseudo-random 64-bit value as a uint64 from the default
Source.

type Rand 
---------

A Rand is a source of random numbers.

```go
type Rand struct {
    // contains filtered or unexported fields
}
```

### func New 

```go
func New(src Source) *Rand
```

New returns a new Rand that uses random values from src to generate
other random values.

### func (\*Rand) ExpFloat64 

```go
func (r *Rand) ExpFloat64() float64
```

ExpFloat64 returns an exponentially distributed float64 in the range (0,
+math.MaxFloat64\] with an exponential distribution whose rate parameter
(lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution
with a different rate parameter, callers can adjust the output using:

```go
sample = ExpFloat64() / desiredRateParameter
```

### func (\*Rand) Float32 

```go
func (r *Rand) Float32() float32
```

Float32 returns, as a float32, a pseudo-random number in the half-open
interval \[0.0,1.0).

### func (\*Rand) Float64 

```go
func (r *Rand) Float64() float64
```

Float64 returns, as a float64, a pseudo-random number in the half-open
interval \[0.0,1.0).

### func (\*Rand) Int 

```go
func (r *Rand) Int() int
```

Int returns a non-negative pseudo-random int.

### func (\*Rand) Int31 

```go
func (r *Rand) Int31() int32
```

Int31 returns a non-negative pseudo-random 31-bit integer as an int32.

### func (\*Rand) Int31n 

```go
func (r *Rand) Int31n(n int32) int32
```

Int31n returns, as an int32, a non-negative pseudo-random number in the
half-open interval \[0,n). It panics if n \<= 0.

### func (\*Rand) Int63 

```go
func (r *Rand) Int63() int64
```

Int63 returns a non-negative pseudo-random 63-bit integer as an int64.

### func (\*Rand) Int63n 

```go
func (r *Rand) Int63n(n int64) int64
```

Int63n returns, as an int64, a non-negative pseudo-random number in the
half-open interval \[0,n). It panics if n \<= 0.

### func (\*Rand) Intn 

```go
func (r *Rand) Intn(n int) int
```

Intn returns, as an int, a non-negative pseudo-random number in the
half-open interval \[0,n). It panics if n \<= 0.

### func (\*Rand) NormFloat64 

```go
func (r *Rand) NormFloat64() float64
```

NormFloat64 returns a normally distributed float64 in the range
-math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard
normal distribution (mean = 0, stddev = 1). To produce a different
normal distribution, callers can adjust the output using:

```go
sample = NormFloat64() * desiredStdDev + desiredMean
```

### func (\*Rand) Perm 

```go
func (r *Rand) Perm(n int) []int
```

Perm returns, as a slice of n ints, a pseudo-random permutation of the
integers in the half-open interval \[0,n).

### func (\*Rand) Read 

```go
func (r *Rand) Read(p []byte) (n int, err error)
```

Read generates len(p) random bytes and writes them into p. It always
returns len(p) and a nil error. Read should not be called concurrently
with any other Rand method.

### func (\*Rand) Seed 

```go
func (r *Rand) Seed(seed int64)
```

Seed uses the provided seed value to initialize the generator to a
deterministic state. Seed should not be called concurrently with any
other Rand method.

### func (\*Rand) Shuffle 

```go
func (r *Rand) Shuffle(n int, swap func(i, j int))
```

Shuffle pseudo-randomizes the order of elements. n is the number of
elements. Shuffle panics if n \< 0. swap swaps the elements with indexes
i and j.

### func (\*Rand) Uint32 

```go
func (r *Rand) Uint32() uint32
```

Uint32 returns a pseudo-random 32-bit value as a uint32.

### func (\*Rand) Uint64 

```go
func (r *Rand) Uint64() uint64
```

Uint64 returns a pseudo-random 64-bit value as a uint64.

type Source 
-----------

A Source represents a source of uniformly-distributed pseudo-random
int64 values in the range \[0, 1\<\<63).

A Source is not safe for concurrent use by multiple goroutines.

```go
type Source interface {
    Int63() int64
    Seed(seed int64)
}
```

### func NewSource 

```go
func NewSource(seed int64) Source
```

NewSource returns a new pseudo-random Source seeded with the given
value. Unlike the default Source used by top-level functions, this
source is not safe for concurrent use by multiple goroutines. The
returned Source implements Source64.

type Source64 
--------------------------------------------

A Source64 is a Source that can also generate uniformly-distributed
pseudo-random uint64 values in the range \[0, 1\<\<64) directly. If a
Rand r\'s underlying Source s implements Source64, then r.Uint64 returns
the result of one call to s.Uint64 instead of making two calls to
s.Int63.

```go
type Source64 interface {
    Source
    Uint64() uint64
}
```

type Zipf 
---------

A Zipf generates Zipf distributed variates.

```go
type Zipf struct {
    // contains filtered or unexported fields
}
```

### func NewZipf 

```go
func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf
```

NewZipf returns a Zipf variate generator. The generator generates values
k ∈ \[0, imax\] such that P(k) is proportional to (v + k) \*\* (-s).
Requirements: s \> 1 and v \>= 1.

### func (\*Zipf) Uint64 

```go
func (z *Zipf) Uint64() uint64
```

Uint64 returns a value drawn from the Zipf distribution described by the
Zipf object.

 
© Google, Inc.\
Licensed under the Creative Commons Attribution License 3.0.\
https://golang.org/pkg/math/rand/>

